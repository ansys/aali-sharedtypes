// Copyright (C) 2025 ANSYS, Inc. and/or its affiliates.
// SPDX-License-Identifier: MIT
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Code generated by internal/gen/logical_type/gen.go; DO NOT EDIT.

package aali_graphdb

import (
	"encoding/json"
	"fmt"
)

// This is the interface to implement on any kuzu Logical type, to indicate that it is such.
type LogicalType interface {
	IsKuzuLogicalType()
}

// Keep all the tags of the logical types in 1 place. This is especially useful for unmarshaling.
type logicalTypeTag string

const (
  {{ range . }}
		{{- toLower .Tag }}LtTag logicalTypeTag = {{ printf "%q" .Tag }}
	{{ end }}
)

// In order to unmarshal types which have a field that is a general LogicalType, we need to wrap it
// in an explicit type.
type logicalTypeUnmarshalHelper struct {
	LogicalType
}

// the helper should marshal in the same way the inner type does
func (lth logicalTypeUnmarshalHelper) MarshalJSON() ([]byte, error) {
	return json.Marshal(lth.LogicalType)
}

// In order to handle unmarshaling of logical types, we need to explicitly enumerate all possible tags.
func (lth *logicalTypeUnmarshalHelper) UnmarshalJSON(data []byte) error {
	var mapVariant map[string]json.RawMessage
	err := json.Unmarshal(data, &mapVariant)
	if err != nil {
		// not map variant, see if it is string
		var unitVariant logicalTypeTag
		err = json.Unmarshal(data, &unitVariant)
		if err != nil {
			// something else
			return fmt.Errorf("unable to unmarshal to a unit variant (string) or map variant (map[string]any w/ length 1)")
		}
		switch unitVariant {
		{{- range . -}}
			{{- if .UnitVariant -}}
				case {{ toLower .Tag }}LtTag:
					var logicalType {{ .Tag }}LogicalType
					err := json.Unmarshal(data, &logicalType)
					if err != nil {
						return err
					}
					lth.LogicalType = logicalType
					return nil
			{{- end }}
		{{ end -}}
		default:
			return fmt.Errorf("unknown unit variant %q", unitVariant)
		}
	} else if len(mapVariant) == 1 {
		// looks like map variant
		for k := range mapVariant {
			tagVal := logicalTypeTag(k)
			switch tagVal {
			{{- range . -}}
				{{- if not .UnitVariant -}}
					case {{ toLower .Tag }}LtTag:
						var logicalType {{ .Tag }}LogicalType
						err := json.Unmarshal(data, &logicalType)
						if err != nil {
							return err
						}
						lth.LogicalType = logicalType
						return nil
				{{- end }}
			{{ end -}}
			default:
				return fmt.Errorf("unknown map variant %q", tagVal)
			}
		}
	}
	// something else completely
	return fmt.Errorf("unable to unmarshal to a unit variant (string) or map variant (map[string]any w/ length 1)")
}

func (lth logicalTypeUnmarshalHelper) getInnerLogicalType() LogicalType {
	return lth.LogicalType
}

func newLogicalTypeHelper(lt LogicalType) logicalTypeUnmarshalHelper {
	return logicalTypeUnmarshalHelper{lt}
}

func getTwopleLogicalTypeFromHelper(tups []Twople[string, logicalTypeUnmarshalHelper]) []Twople[string, LogicalType] {
	ltTups := make([]Twople[string, LogicalType], len(tups))
	for i, tup := range tups {
		newTup := Twople[string, LogicalType]{tup.a, tup.b.LogicalType}
		ltTups[i] = newTup
	}
	return ltTups
}

{{ range . }}
	/* {{ toUpper .Tag }} */

	{{ if .UnitVariant }}
		type {{ .Tag }}LogicalType struct{}

		func (lt {{ .Tag }}LogicalType) IsKuzuLogicalType() {}
		func (lt {{ .Tag }}LogicalType) MarshalJSON() ([]byte, error) {
			return json.Marshal({{ toLower .Tag }}LtTag)
		}
		func (lt *{{ .Tag }}LogicalType) UnmarshalJSON(data []byte) error {
			return unmarshalUnitVariant(data, {{ toLower .Tag }}LtTag)
		}
	{{ else }}
		type {{ .Tag }}LogicalType struct {
			{{ range .Fields }}
				{{- .Name }} {{ .Type }} {{ .Tag }}
			{{ end }}
		}

		func (lt {{ .Tag }}LogicalType) IsKuzuLogicalType() {}
		func (lt {{ .Tag }}LogicalType) MarshalJSON() ([]byte, error) {
			intermediate := {{ toLower .Tag }}LogicalType(lt)
			return json.Marshal(externallyTagged[{{ toLower .Tag }}LogicalType]{&intermediate})
		}
		func (lt *{{ .Tag }}LogicalType) UnmarshalJSON(data []byte) error {
			var intermediate externallyTagged[{{ toLower .Tag}}LogicalTypeUnmarshalHelper]
			if err := json.Unmarshal(data, &intermediate); err != nil {
				return err
			}
			*lt = {{ .Tag }}LogicalType{
				{{ range .Fields }}
					{{- if  eq .UnmarshallerType "" }}
						{{- .Name }}: intermediate.value.{{ .Name }},
					{{- else }}
						{{- .Name }}: {{ .Converter }}(intermediate.value.{{ .Name }}),
					{{- end }}
				{{ end }}
			}
			return nil
		}

		type {{ toLower .Tag }}LogicalType {{ .Tag }}LogicalType

		func (lt {{ toLower .Tag }}LogicalType) tag() string { return string({{ toLower .Tag }}LtTag) }

		type {{ toLower .Tag}}LogicalTypeUnmarshalHelper struct {
			{{ range .Fields }}
				{{- if eq .UnmarshallerType "" }}
					{{- .Name }} {{ .Type }} {{ .Tag }}
				{{- else }}
					{{- .Name }} {{ .UnmarshallerType }} {{ .Tag }}
				{{- end }}
			{{ end }}
		}

		func (lt {{ toLower .Tag }}LogicalTypeUnmarshalHelper) tag() string { return string({{ toLower .Tag }}LtTag) }
	{{ end  }}
{{ end }}

/* helpers */

func unmarshalUnitVariant(data []byte, expected logicalTypeTag) error {
	var tmp logicalTypeTag
	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}
	if tmp == expected {
		return nil
	} else {
		return fmt.Errorf("expected string %q, got %q", expected, tmp)
	}
}
