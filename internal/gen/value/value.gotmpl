// Copyright (C) 2025 ANSYS, Inc. and/or its affiliates.
// SPDX-License-Identifier: MIT
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Code generated by internal/gen/value/gen.go; DO NOT EDIT.

package aali_graphdb

import (
	"fmt"
	"encoding/json"
	"time"

	"cloud.google.com/go/civil"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// This is the interface to implement on any kuzu value, to indicate that it is such.
type Value interface {
	IsKuzuValue()
}

// Keep all the tags of the values in 1 place. This is especially useful for unmarshaling.
type valueTag string

const (
  {{ range . }}
		{{- toLower .Tag }}ValTag valueTag = {{ printf "%q" .Tag }}
	{{ end }}
)

// In order to unmarshal types which have a field that is a general Value, we need to wrap it
// in an explicit type.
type valueUnmarshalHelper struct {
	Value
}

// the helper should marshal in the same way the inner type does
func (vh valueUnmarshalHelper) MarshalJSON() ([]byte, error) {
	return json.Marshal(vh.Value)
}

// In order to handle unmarshaling of values, we need to explicitly enumerate all possible tags.
func (vh *valueUnmarshalHelper) UnmarshalJSON(data []byte) error {
	var valueMap map[string]json.RawMessage
	err := json.Unmarshal(data, &valueMap)
	if err != nil {
		return err
	}

	if len(valueMap) != 1 {
		return fmt.Errorf("expected map of length 1 but got %d", len(valueMap))
	}

	for k := range valueMap {
		tag := valueTag(k)
		switch tag {
		{{ range . -}}
			case {{ toLower .Tag }}ValTag:
				var value {{ .Tag }}Value
				err := json.Unmarshal(data, &value)
				if err != nil {
					return err
				}
				vh.Value = value
				return nil
		{{ end -}}
		default:
			return fmt.Errorf("unknown value tag %q", tag)
		}
	}
	panic("this should be unreachable")
}

func newValueUnmarshalHelper(v Value) valueUnmarshalHelper {
	return valueUnmarshalHelper{v}
}

func (v valueUnmarshalHelper) getInnerValue() Value {
	return v.Value
}

{{ range . }}
	/* {{ toUpper .Tag }} */

	{{ if eq .ValueType "alias" }}

		type {{ .Tag }}Value {{ .Type }}

		func (v {{ .Tag }}Value) IsKuzuValue() {}
		func (v {{ .Tag }}Value) MarshalJSON() ([]byte, error) {
			intermediate := {{ toLower .Tag }}Value(v)
			return json.Marshal(externallyTagged[{{ toLower .Tag }}Value]{&intermediate})
		}
		func (v *{{ .Tag }}Value) UnmarshalJSON(data []byte) error {
			var intermediate externallyTagged[{{ toLower .Tag }}Value]
			if err := json.Unmarshal(data, &intermediate); err != nil {
				return err
			}
			*v = {{ .Tag }}Value(*intermediate.value)
			return nil
		}

		type {{ toLower .Tag }}Value {{ .Tag }}Value

		func (v {{ toLower .Tag }}Value) tag() string { return string({{ toLower .Tag }}ValTag) }
		{{- if ne .ConverterType "" }}
			func (v {{ toLower .Tag }}Value) MarshalJSON() ([]byte, error) {
				var intermediate {{ .ConverterType }}
				intermediate = {{ .ToConverter }}(v)
				return json.Marshal(intermediate)
			}
			func (v *{{ toLower .Tag }}Value) UnmarshalJSON(data []byte) error {
				var intermediate {{ .ConverterType }}
				err := json.Unmarshal(data, &intermediate)
				if err != nil {
					return err
				}
				*v = {{ .FromConverter }}(intermediate)
				return nil
			}
		{{ end }}

	{{ else if eq .ValueType "struct" }}

		type {{ .Tag }}Value struct {
			{{ range .Fields -}}
				{{ .Name }} {{ .Type }} {{ .Tag }}
			{{ end -}}
		}
		func (v {{ .Tag }}Value) IsKuzuValue() {}
		func (v {{ .Tag }}Value) MarshalJSON() ([]byte, error) {
			intermediate := {{ toLower .Tag }}Value{
				{{- range .Fields }}
					{{- if eq .ToConverter "" }}
						{{ .Name }}: v.{{ .Name }},
					{{- else }}
						{{ .Name }}: {{ .ToConverter }}(v.{{ .Name }}),
					{{- end }}
				{{- end }}
			}
			return json.Marshal(externallyTagged[{{ toLower .Tag }}Value]{&intermediate})
		}
		func (v *{{ .Tag }}Value) UnmarshalJSON(data []byte) error {
			var intermediate externallyTagged[{{ toLower .Tag }}Value]
			if err := json.Unmarshal(data, &intermediate); err != nil {
				return err
			}
			*v = {{ .Tag }}Value{
				{{- range .Fields }}
					{{- if eq .FromConverter "" }}
						{{ .Name }}: intermediate.value.{{ .Name }},
					{{- else }}
						{{ .Name }}: {{ .FromConverter }}(intermediate.value.{{ .Name }}),
					{{- end }}
				{{- end }}
			}
			return nil
		}

		type {{ toLower .Tag }}Value struct {
			{{- range .Fields }}
				{{- if eq .ConverterType "" }}
					{{ .Name }} {{ .Type }} {{ .Tag }}
				{{- else }}
					{{ .Name }} {{ .ConverterType }} {{ .Tag }}
				{{- end }}
			{{- end }}
		}
		func (v {{ toLower .Tag }}Value) tag() string { return string({{ toLower .Tag }}ValTag) }

		{{- if ne .ConverterType "" }}
			func (v {{ toLower .Tag }}Value) MarshalJSON() ([]byte, error) {
				var intermediate {{ .ConverterType }}
				intermediate = {{ .ToConverter }}(v)
				return json.Marshal(intermediate)
			}
			func (v *{{ toLower .Tag }}Value) UnmarshalJSON(data []byte) error {
				var intermediate {{ .ConverterType }}
				err := json.Unmarshal(data, &intermediate)
				if err != nil {
					return err
				}
				*v = {{ .FromConverter }}(intermediate)
				return nil
			}
		{{ end }}
	{{ else }}
		{{ fail (printf "unsupported type %q for %q" .ValueType .Tag) }}
	{{ end  }}
{{ end }}
