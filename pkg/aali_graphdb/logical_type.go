// Copyright (C) 2025 ANSYS, Inc. and/or its affiliates.
// SPDX-License-Identifier: MIT
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Code generated by internal/gen/logical_type/gen.go; DO NOT EDIT.

package aali_graphdb

import (
	"encoding/json"
	"fmt"
)

// This is the interface to implement on any kuzu Logical type, to indicate that it is such.
type LogicalType interface {
	IsKuzuLogicalType()
}

// Keep all the tags of the logical types in 1 place. This is especially useful for unmarshaling.
type logicalTypeTag string

const (
	anyLtTag          logicalTypeTag = "Any"
	boolLtTag         logicalTypeTag = "Bool"
	serialLtTag       logicalTypeTag = "Serial"
	int64LtTag        logicalTypeTag = "Int64"
	int32LtTag        logicalTypeTag = "Int32"
	int16LtTag        logicalTypeTag = "Int16"
	int8LtTag         logicalTypeTag = "Int8"
	uint64LtTag       logicalTypeTag = "UInt64"
	uint32LtTag       logicalTypeTag = "UInt32"
	uint16LtTag       logicalTypeTag = "UInt16"
	uint8LtTag        logicalTypeTag = "UInt8"
	int128LtTag       logicalTypeTag = "Int128"
	doubleLtTag       logicalTypeTag = "Double"
	floatLtTag        logicalTypeTag = "Float"
	dateLtTag         logicalTypeTag = "Date"
	intervalLtTag     logicalTypeTag = "Interval"
	timestampLtTag    logicalTypeTag = "Timestamp"
	timestamptzLtTag  logicalTypeTag = "TimestampTz"
	timestampnsLtTag  logicalTypeTag = "TimestampNs"
	timestampmsLtTag  logicalTypeTag = "TimestampMs"
	timestampsecLtTag logicalTypeTag = "TimestampSec"
	internalidLtTag   logicalTypeTag = "InternalID"
	stringLtTag       logicalTypeTag = "String"
	blobLtTag         logicalTypeTag = "Blob"
	listLtTag         logicalTypeTag = "List"
	arrayLtTag        logicalTypeTag = "Array"
	structLtTag       logicalTypeTag = "Struct"
	nodeLtTag         logicalTypeTag = "Node"
	relLtTag          logicalTypeTag = "Rel"
	recursiverelLtTag logicalTypeTag = "RecursiveRel"
	mapLtTag          logicalTypeTag = "Map"
	unionLtTag        logicalTypeTag = "Union"
	uuidLtTag         logicalTypeTag = "UUID"
	decimalLtTag      logicalTypeTag = "Decimal"
)

// In order to unmarshal types which have a field that is a general LogicalType, we need to wrap it
// in an explicit type.
type logicalTypeUnmarshalHelper struct {
	LogicalType
}

// the helper should marshal in the same way the inner type does
func (lth logicalTypeUnmarshalHelper) MarshalJSON() ([]byte, error) {
	return json.Marshal(lth.LogicalType)
}

// In order to handle unmarshaling of logical types, we need to explicitly enumerate all possible tags.
func (lth *logicalTypeUnmarshalHelper) UnmarshalJSON(data []byte) error {
	var mapVariant map[string]json.RawMessage
	err := json.Unmarshal(data, &mapVariant)
	if err != nil {
		// not map variant, see if it is string
		var unitVariant logicalTypeTag
		err = json.Unmarshal(data, &unitVariant)
		if err != nil {
			// something else
			return fmt.Errorf("unable to unmarshal to a unit variant (string) or map variant (map[string]any w/ length 1)")
		}
		switch unitVariant {
		case anyLtTag:
			var logicalType AnyLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case boolLtTag:
			var logicalType BoolLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case serialLtTag:
			var logicalType SerialLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case int64LtTag:
			var logicalType Int64LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case int32LtTag:
			var logicalType Int32LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case int16LtTag:
			var logicalType Int16LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case int8LtTag:
			var logicalType Int8LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case uint64LtTag:
			var logicalType UInt64LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case uint32LtTag:
			var logicalType UInt32LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case uint16LtTag:
			var logicalType UInt16LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case uint8LtTag:
			var logicalType UInt8LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case int128LtTag:
			var logicalType Int128LogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case doubleLtTag:
			var logicalType DoubleLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case floatLtTag:
			var logicalType FloatLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case dateLtTag:
			var logicalType DateLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case intervalLtTag:
			var logicalType IntervalLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case timestampLtTag:
			var logicalType TimestampLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case timestamptzLtTag:
			var logicalType TimestampTzLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case timestampnsLtTag:
			var logicalType TimestampNsLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case timestampmsLtTag:
			var logicalType TimestampMsLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case timestampsecLtTag:
			var logicalType TimestampSecLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case internalidLtTag:
			var logicalType InternalIDLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case stringLtTag:
			var logicalType StringLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case blobLtTag:
			var logicalType BlobLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil

		case nodeLtTag:
			var logicalType NodeLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case relLtTag:
			var logicalType RelLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil
		case recursiverelLtTag:
			var logicalType RecursiveRelLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil

		case uuidLtTag:
			var logicalType UUIDLogicalType
			err := json.Unmarshal(data, &logicalType)
			if err != nil {
				return err
			}
			lth.LogicalType = logicalType
			return nil

		default:
			return fmt.Errorf("unknown unit variant %q", unitVariant)
		}
	} else if len(mapVariant) == 1 {
		// looks like map variant
		for k := range mapVariant {
			tagVal := logicalTypeTag(k)
			switch tagVal {

			case listLtTag:
				var logicalType ListLogicalType
				err := json.Unmarshal(data, &logicalType)
				if err != nil {
					return err
				}
				lth.LogicalType = logicalType
				return nil
			case arrayLtTag:
				var logicalType ArrayLogicalType
				err := json.Unmarshal(data, &logicalType)
				if err != nil {
					return err
				}
				lth.LogicalType = logicalType
				return nil
			case structLtTag:
				var logicalType StructLogicalType
				err := json.Unmarshal(data, &logicalType)
				if err != nil {
					return err
				}
				lth.LogicalType = logicalType
				return nil

			case mapLtTag:
				var logicalType MapLogicalType
				err := json.Unmarshal(data, &logicalType)
				if err != nil {
					return err
				}
				lth.LogicalType = logicalType
				return nil
			case unionLtTag:
				var logicalType UnionLogicalType
				err := json.Unmarshal(data, &logicalType)
				if err != nil {
					return err
				}
				lth.LogicalType = logicalType
				return nil

			case decimalLtTag:
				var logicalType DecimalLogicalType
				err := json.Unmarshal(data, &logicalType)
				if err != nil {
					return err
				}
				lth.LogicalType = logicalType
				return nil
			default:
				return fmt.Errorf("unknown map variant %q", tagVal)
			}
		}
	}
	// something else completely
	return fmt.Errorf("unable to unmarshal to a unit variant (string) or map variant (map[string]any w/ length 1)")
}

func (lth logicalTypeUnmarshalHelper) getInnerLogicalType() LogicalType {
	return lth.LogicalType
}

func newLogicalTypeHelper(lt LogicalType) logicalTypeUnmarshalHelper {
	return logicalTypeUnmarshalHelper{lt}
}

func getTwopleLogicalTypeFromHelper(tups []Twople[string, logicalTypeUnmarshalHelper]) []Twople[string, LogicalType] {
	ltTups := make([]Twople[string, LogicalType], len(tups))
	for i, tup := range tups {
		newTup := Twople[string, LogicalType]{tup.a, tup.b.LogicalType}
		ltTups[i] = newTup
	}
	return ltTups
}

/* ANY */

type AnyLogicalType struct{}

func (lt AnyLogicalType) IsKuzuLogicalType() {}
func (lt AnyLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(anyLtTag)
}
func (lt *AnyLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, anyLtTag)
}

/* BOOL */

type BoolLogicalType struct{}

func (lt BoolLogicalType) IsKuzuLogicalType() {}
func (lt BoolLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(boolLtTag)
}
func (lt *BoolLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, boolLtTag)
}

/* SERIAL */

type SerialLogicalType struct{}

func (lt SerialLogicalType) IsKuzuLogicalType() {}
func (lt SerialLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(serialLtTag)
}
func (lt *SerialLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, serialLtTag)
}

/* INT64 */

type Int64LogicalType struct{}

func (lt Int64LogicalType) IsKuzuLogicalType() {}
func (lt Int64LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(int64LtTag)
}
func (lt *Int64LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, int64LtTag)
}

/* INT32 */

type Int32LogicalType struct{}

func (lt Int32LogicalType) IsKuzuLogicalType() {}
func (lt Int32LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(int32LtTag)
}
func (lt *Int32LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, int32LtTag)
}

/* INT16 */

type Int16LogicalType struct{}

func (lt Int16LogicalType) IsKuzuLogicalType() {}
func (lt Int16LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(int16LtTag)
}
func (lt *Int16LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, int16LtTag)
}

/* INT8 */

type Int8LogicalType struct{}

func (lt Int8LogicalType) IsKuzuLogicalType() {}
func (lt Int8LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(int8LtTag)
}
func (lt *Int8LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, int8LtTag)
}

/* UINT64 */

type UInt64LogicalType struct{}

func (lt UInt64LogicalType) IsKuzuLogicalType() {}
func (lt UInt64LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(uint64LtTag)
}
func (lt *UInt64LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, uint64LtTag)
}

/* UINT32 */

type UInt32LogicalType struct{}

func (lt UInt32LogicalType) IsKuzuLogicalType() {}
func (lt UInt32LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(uint32LtTag)
}
func (lt *UInt32LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, uint32LtTag)
}

/* UINT16 */

type UInt16LogicalType struct{}

func (lt UInt16LogicalType) IsKuzuLogicalType() {}
func (lt UInt16LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(uint16LtTag)
}
func (lt *UInt16LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, uint16LtTag)
}

/* UINT8 */

type UInt8LogicalType struct{}

func (lt UInt8LogicalType) IsKuzuLogicalType() {}
func (lt UInt8LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(uint8LtTag)
}
func (lt *UInt8LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, uint8LtTag)
}

/* INT128 */

type Int128LogicalType struct{}

func (lt Int128LogicalType) IsKuzuLogicalType() {}
func (lt Int128LogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(int128LtTag)
}
func (lt *Int128LogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, int128LtTag)
}

/* DOUBLE */

type DoubleLogicalType struct{}

func (lt DoubleLogicalType) IsKuzuLogicalType() {}
func (lt DoubleLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(doubleLtTag)
}
func (lt *DoubleLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, doubleLtTag)
}

/* FLOAT */

type FloatLogicalType struct{}

func (lt FloatLogicalType) IsKuzuLogicalType() {}
func (lt FloatLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(floatLtTag)
}
func (lt *FloatLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, floatLtTag)
}

/* DATE */

type DateLogicalType struct{}

func (lt DateLogicalType) IsKuzuLogicalType() {}
func (lt DateLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(dateLtTag)
}
func (lt *DateLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, dateLtTag)
}

/* INTERVAL */

type IntervalLogicalType struct{}

func (lt IntervalLogicalType) IsKuzuLogicalType() {}
func (lt IntervalLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(intervalLtTag)
}
func (lt *IntervalLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, intervalLtTag)
}

/* TIMESTAMP */

type TimestampLogicalType struct{}

func (lt TimestampLogicalType) IsKuzuLogicalType() {}
func (lt TimestampLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(timestampLtTag)
}
func (lt *TimestampLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, timestampLtTag)
}

/* TIMESTAMPTZ */

type TimestampTzLogicalType struct{}

func (lt TimestampTzLogicalType) IsKuzuLogicalType() {}
func (lt TimestampTzLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(timestamptzLtTag)
}
func (lt *TimestampTzLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, timestamptzLtTag)
}

/* TIMESTAMPNS */

type TimestampNsLogicalType struct{}

func (lt TimestampNsLogicalType) IsKuzuLogicalType() {}
func (lt TimestampNsLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(timestampnsLtTag)
}
func (lt *TimestampNsLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, timestampnsLtTag)
}

/* TIMESTAMPMS */

type TimestampMsLogicalType struct{}

func (lt TimestampMsLogicalType) IsKuzuLogicalType() {}
func (lt TimestampMsLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(timestampmsLtTag)
}
func (lt *TimestampMsLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, timestampmsLtTag)
}

/* TIMESTAMPSEC */

type TimestampSecLogicalType struct{}

func (lt TimestampSecLogicalType) IsKuzuLogicalType() {}
func (lt TimestampSecLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(timestampsecLtTag)
}
func (lt *TimestampSecLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, timestampsecLtTag)
}

/* INTERNALID */

type InternalIDLogicalType struct{}

func (lt InternalIDLogicalType) IsKuzuLogicalType() {}
func (lt InternalIDLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(internalidLtTag)
}
func (lt *InternalIDLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, internalidLtTag)
}

/* STRING */

type StringLogicalType struct{}

func (lt StringLogicalType) IsKuzuLogicalType() {}
func (lt StringLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(stringLtTag)
}
func (lt *StringLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, stringLtTag)
}

/* BLOB */

type BlobLogicalType struct{}

func (lt BlobLogicalType) IsKuzuLogicalType() {}
func (lt BlobLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(blobLtTag)
}
func (lt *BlobLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, blobLtTag)
}

/* LIST */

type ListLogicalType struct {
	ChildType LogicalType `json:"child_type"`
}

func (lt ListLogicalType) IsKuzuLogicalType() {}
func (lt ListLogicalType) MarshalJSON() ([]byte, error) {
	intermediate := listLogicalType(lt)
	return json.Marshal(externallyTagged[listLogicalType]{&intermediate})
}
func (lt *ListLogicalType) UnmarshalJSON(data []byte) error {
	var intermediate externallyTagged[listLogicalTypeUnmarshalHelper]
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return err
	}
	*lt = ListLogicalType{
		ChildType: logicalTypeUnmarshalHelper.getInnerLogicalType(intermediate.value.ChildType),
	}
	return nil
}

type listLogicalType ListLogicalType

func (lt listLogicalType) tag() string { return string(listLtTag) }

type listLogicalTypeUnmarshalHelper struct {
	ChildType logicalTypeUnmarshalHelper `json:"child_type"`
}

func (lt listLogicalTypeUnmarshalHelper) tag() string { return string(listLtTag) }

/* ARRAY */

type ArrayLogicalType struct {
	ChildType   LogicalType `json:"child_type"`
	NumElements uint64      `json:"num_elements"`
}

func (lt ArrayLogicalType) IsKuzuLogicalType() {}
func (lt ArrayLogicalType) MarshalJSON() ([]byte, error) {
	intermediate := arrayLogicalType(lt)
	return json.Marshal(externallyTagged[arrayLogicalType]{&intermediate})
}
func (lt *ArrayLogicalType) UnmarshalJSON(data []byte) error {
	var intermediate externallyTagged[arrayLogicalTypeUnmarshalHelper]
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return err
	}
	*lt = ArrayLogicalType{
		ChildType:   logicalTypeUnmarshalHelper.getInnerLogicalType(intermediate.value.ChildType),
		NumElements: intermediate.value.NumElements,
	}
	return nil
}

type arrayLogicalType ArrayLogicalType

func (lt arrayLogicalType) tag() string { return string(arrayLtTag) }

type arrayLogicalTypeUnmarshalHelper struct {
	ChildType   logicalTypeUnmarshalHelper `json:"child_type"`
	NumElements uint64                     `json:"num_elements"`
}

func (lt arrayLogicalTypeUnmarshalHelper) tag() string { return string(arrayLtTag) }

/* STRUCT */

type StructLogicalType struct {
	Fields []Twople[string, LogicalType] `json:"fields"`
}

func (lt StructLogicalType) IsKuzuLogicalType() {}
func (lt StructLogicalType) MarshalJSON() ([]byte, error) {
	intermediate := structLogicalType(lt)
	return json.Marshal(externallyTagged[structLogicalType]{&intermediate})
}
func (lt *StructLogicalType) UnmarshalJSON(data []byte) error {
	var intermediate externallyTagged[structLogicalTypeUnmarshalHelper]
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return err
	}
	*lt = StructLogicalType{
		Fields: getTwopleLogicalTypeFromHelper(intermediate.value.Fields),
	}
	return nil
}

type structLogicalType StructLogicalType

func (lt structLogicalType) tag() string { return string(structLtTag) }

type structLogicalTypeUnmarshalHelper struct {
	Fields []Twople[string, logicalTypeUnmarshalHelper] `json:"fields"`
}

func (lt structLogicalTypeUnmarshalHelper) tag() string { return string(structLtTag) }

/* NODE */

type NodeLogicalType struct{}

func (lt NodeLogicalType) IsKuzuLogicalType() {}
func (lt NodeLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(nodeLtTag)
}
func (lt *NodeLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, nodeLtTag)
}

/* REL */

type RelLogicalType struct{}

func (lt RelLogicalType) IsKuzuLogicalType() {}
func (lt RelLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(relLtTag)
}
func (lt *RelLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, relLtTag)
}

/* RECURSIVEREL */

type RecursiveRelLogicalType struct{}

func (lt RecursiveRelLogicalType) IsKuzuLogicalType() {}
func (lt RecursiveRelLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(recursiverelLtTag)
}
func (lt *RecursiveRelLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, recursiverelLtTag)
}

/* MAP */

type MapLogicalType struct {
	KeyType   LogicalType `json:"key_type"`
	ValueType LogicalType `json:"value_type"`
}

func (lt MapLogicalType) IsKuzuLogicalType() {}
func (lt MapLogicalType) MarshalJSON() ([]byte, error) {
	intermediate := mapLogicalType(lt)
	return json.Marshal(externallyTagged[mapLogicalType]{&intermediate})
}
func (lt *MapLogicalType) UnmarshalJSON(data []byte) error {
	var intermediate externallyTagged[mapLogicalTypeUnmarshalHelper]
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return err
	}
	*lt = MapLogicalType{
		KeyType:   logicalTypeUnmarshalHelper.getInnerLogicalType(intermediate.value.KeyType),
		ValueType: logicalTypeUnmarshalHelper.getInnerLogicalType(intermediate.value.ValueType),
	}
	return nil
}

type mapLogicalType MapLogicalType

func (lt mapLogicalType) tag() string { return string(mapLtTag) }

type mapLogicalTypeUnmarshalHelper struct {
	KeyType   logicalTypeUnmarshalHelper `json:"key_type"`
	ValueType logicalTypeUnmarshalHelper `json:"value_type"`
}

func (lt mapLogicalTypeUnmarshalHelper) tag() string { return string(mapLtTag) }

/* UNION */

type UnionLogicalType struct {
	Fields []Twople[string, LogicalType] `json:"fields"`
}

func (lt UnionLogicalType) IsKuzuLogicalType() {}
func (lt UnionLogicalType) MarshalJSON() ([]byte, error) {
	intermediate := unionLogicalType(lt)
	return json.Marshal(externallyTagged[unionLogicalType]{&intermediate})
}
func (lt *UnionLogicalType) UnmarshalJSON(data []byte) error {
	var intermediate externallyTagged[unionLogicalTypeUnmarshalHelper]
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return err
	}
	*lt = UnionLogicalType{
		Fields: getTwopleLogicalTypeFromHelper(intermediate.value.Fields),
	}
	return nil
}

type unionLogicalType UnionLogicalType

func (lt unionLogicalType) tag() string { return string(unionLtTag) }

type unionLogicalTypeUnmarshalHelper struct {
	Fields []Twople[string, logicalTypeUnmarshalHelper] `json:"fields"`
}

func (lt unionLogicalTypeUnmarshalHelper) tag() string { return string(unionLtTag) }

/* UUID */

type UUIDLogicalType struct{}

func (lt UUIDLogicalType) IsKuzuLogicalType() {}
func (lt UUIDLogicalType) MarshalJSON() ([]byte, error) {
	return json.Marshal(uuidLtTag)
}
func (lt *UUIDLogicalType) UnmarshalJSON(data []byte) error {
	return unmarshalUnitVariant(data, uuidLtTag)
}

/* DECIMAL */

type DecimalLogicalType struct {
	Precision uint32 `json:"precision"`
	Scale     uint32 `json:"scale"`
}

func (lt DecimalLogicalType) IsKuzuLogicalType() {}
func (lt DecimalLogicalType) MarshalJSON() ([]byte, error) {
	intermediate := decimalLogicalType(lt)
	return json.Marshal(externallyTagged[decimalLogicalType]{&intermediate})
}
func (lt *DecimalLogicalType) UnmarshalJSON(data []byte) error {
	var intermediate externallyTagged[decimalLogicalTypeUnmarshalHelper]
	if err := json.Unmarshal(data, &intermediate); err != nil {
		return err
	}
	*lt = DecimalLogicalType{
		Precision: intermediate.value.Precision,
		Scale:     intermediate.value.Scale,
	}
	return nil
}

type decimalLogicalType DecimalLogicalType

func (lt decimalLogicalType) tag() string { return string(decimalLtTag) }

type decimalLogicalTypeUnmarshalHelper struct {
	Precision uint32 `json:"precision"`
	Scale     uint32 `json:"scale"`
}

func (lt decimalLogicalTypeUnmarshalHelper) tag() string { return string(decimalLtTag) }

/* helpers */

func unmarshalUnitVariant(data []byte, expected logicalTypeTag) error {
	var tmp logicalTypeTag
	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}
	if tmp == expected {
		return nil
	} else {
		return fmt.Errorf("expected string %q, got %q", expected, tmp)
	}
}
